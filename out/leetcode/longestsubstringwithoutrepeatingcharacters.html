<html><head><title>Leetcode - Longest Substring Without Repeating Characters</title></head><body><h3>描述</h3>

<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters.</p>
</blockquote>

<p>难度：Medium</p>

<p>示例：</p>

<pre><code>Input: &#34;abcabcbb&#34;
Output: 3 
Explanation: The answer is &#34;abc&#34;, with the length of 3. 

Input: &#34;bbbbb&#34;
Output: 1
Explanation: The answer is &#34;b&#34;, with the length of 1.

Input: &#34;pwwkew&#34;
Output: 3
Explanation: The answer is &#34;wke&#34;, with the length of 3. 
             Note that the answer must be a substring, &#34;pwke&#34; is a subsequence and not a substring.
</code></pre>

<h3>想法</h3>

<p>老实说，我的想法只有暴力破解，我又没敢写，想了好久也没想到，最后看了一个大佬写的东西。</p>

<p>算法中有一个东西叫滑动窗口，这个东西可以把很多复杂问题的时间复杂度搞到线性。</p>

<p>这个问题的解就用到了滑动窗口，看看它是咋工作的。</p>

<ol>
<li>初始化一个滑动窗口，有一个左值有一个右值(l和r)，默认它们是0,0</li>
<li>遍历字符串中的每一个字符，r始终是当前遍历的字符所在的位置</li>
<li>如果没发现重复的字符，l保持不动，如果发现了，l跳到该字符之前出现的位置的后一位</li>
<li>重复2,3步，并且每次取窗口大小<code>r-l+1</code>，用每次的窗口大小确定最大长度</li>
</ol>

<p>如果不懂就看<a href="https://blog.csdn.net/qq_40416052/article/details/82815116">图解</a></p>

<h3>实现</h3>

<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();
        char[] chars = s.toCharArray();
        int maxLength = 0;
        for(int l=0,r=0;r&lt;chars.length;r++){
            if (map.containsKey(chars[r])) l = Math.max(map.get(chars[r])+1,l);
            maxLength = Math.max(maxLength,r-l+1);
            map.put(chars[r],r);
        }
        return maxLength;
    }
}
</code></pre>

<p>结果：</p>

<pre><code>Runtime: 6 ms, faster than 91.80% of Java online submissions for Longest Substring Without Repeating Characters.
Memory Usage: 35.3 MB, less than 99.98% of Java online submissions for Longest Substring Without Repeating Characters.
</code></pre>
</body></html>