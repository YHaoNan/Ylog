<html><head><title>Leetcode - Two Sum</title></head><body><h3>描述</h3>

<p>题目：<br/>
&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br/>
You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>难度：Easy</p>

<p>示例：</p>

<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<h3>想法</h3>

<p>如果按照笨方法做，那么每一个数得循环一次，最起码是指数级别的时间复杂度。我想用常数级别的线性时间内完成，于是想到hashmap。</p>

<p>对于nums中的每个数，将它作为键，在数组中的下标作为值存储在Hashmap中，然后遍历一遍，从Hashmap中找是否存在<code>target-nums[i]</code>这个数，如果有，这个数和<code>nums[i]</code>相加就是<code>target</code>，直接返回。</p>

<h3>实现</h3>

<p>Java</p>

<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer,Integer&gt; bucket = new HashMap();
        for(int i=0;i&lt;nums.length;i++){
            int lackNum = target-nums[i];
            if(bucket.get(lackNum)!=null)
                return new int[]{bucket.get(lackNum),i};
            else
                bucket.put(nums[i],i);
        }
        return null;
    }
}
</code></pre>

<p>Python3</p>

<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        bucket = {}
        for i,num in enumerate(nums):
            try:
                index = bucket[target-num]
                return [index,i]
            except:
                pass
            finally:
                bucket[num]=i
</code></pre>

<pre><code>Java版本运行结果：
Runtime: 2 ms, faster than 99.33% of Java online submissions for Two Sum.
Memory Usage: 37.2 MB, less than 98.48% of Java online submissions for Two Sum.

Python版本运行结果：
Runtime: 28 ms, faster than 99.92% of Python3 online submissions for Two Sum.
Memory Usage: 14.4 MB, less than 31.65% of Python3 online submissions for Two Sum.
</code></pre>
</body></html>