<html><head><title>VSCode 扩展开发(十) TreeView</title></head><body><h2>学习目标</h2>

<p>了解TreeView的用法</p>

<h2>开篇寒暄</h2>

<p>TreeView？？听起来挺屌的，应该是个什么树形控件。</p>

<p>Ohh对，就是一个树形控件，它就是我们最常用的侧边栏。</p>

<p><img src="http://nsimg.cn-bj.ufileos.com/img-1560908995830.png" alt="img"/></p>

<p>其实我们很多时候都要和侧边栏打交道，VSCode提供了几个默认的侧边栏，比如文件管理、搜索、版本控制、debug、插件市场等。</p>

<p>我们可以通过本篇文章的学习，学会自己开发一个侧边栏工具。</p>

<p>Ohh，不过别高兴得太早，按照国际惯例，本节也不会写一个非常有用的插件，有用的在实战部分呐，到时候我们写几个上班偷懒的插件，比如在侧边栏里刷知乎，听音乐～～</p>

<h2>配置</h2>

<p>首先要在<code>package.json</code>的<code>contributes</code>节点里配置它一些子节点，如下即是。</p>

<p><code>viewContainers.activitybar</code>节点就是侧边栏中的按钮，在这里配置它的标题，图标和id等信息。</p>

<pre><code class="language-json">&#34;viewsContainers&#34;: {
    &#34;activitybar&#34;: [
        {
            &#34;id&#34;: &#34;my-tree&#34;,
            &#34;title&#34;: &#34;My TreeView&#34;,
            &#34;icon&#34;: &#34;res/tree.svg&#34;
        }
    ]
}
</code></pre>

<p>而<code>views</code>节点则绑定了该按钮弹出的视图：</p>

<pre><code class="language-json">&#34;views&#34;: {
    &#34;my-tree&#34;:[
        {
            &#34;id&#34;: &#34;treeItems&#34;,
            &#34;name&#34;: &#34;Tree Items&#34;
        }
    ]
}
</code></pre>

<p>然后，要在<code>activationEvents</code>节点中配置激活事件，我们要在<code>treeItems</code>触发时激活。</p>

<pre><code class="language-json">&#34;activationEvents&#34;: [
    &#34;onView:treeItems&#34;
]
</code></pre>

<h2>TreeDataProvider</h2>

<p>TreeDataProvider用于提供TreeView展示的数据，它使用泛型设计，需要一个实体类代表树的一个节点，这个实体类继承自<code>vscode.TreeItem</code>：</p>

<pre><code class="language-typescript">export class MyTreeItem extends vscode.TreeItem {
    //label是该条数据显示的文本，collapsibleState是该节点的状态
    //vscode.TreeItemCollapsibleState是个枚举类，有三个值
    //None表示它不能折叠，也就是没有子节点
    //Collapsed表示它可以折叠但是是未打开状态
    //Expanded表示它可以折叠但是是已打开状态
    constructor(public readonly label: string, public readonly collapsibleState: vscode.TreeItemCollapsibleState) {
        super(label, collapsibleState);
    }

    
    iconPath = {
        light: path.join(__filename, &#39;..&#39;, &#39;..&#39;, &#39;res&#39;, &#39;light&#39;, &#39;item.svg&#39;),
        dark: path.join(__filename, &#39;..&#39;, &#39;..&#39;, &#39;res&#39;, &#39;dark&#39;, &#39;item.svg&#39;)
    }

}
</code></pre>

<p>这个实体还有很多属性，比如<code>description</code>、<code>tooltip</code>等，这个查一下API就好了。</p>

<p>有了节点类，我们去创建TreeDataProvider的实现类：</p>

<pre><code class="language-typescript">export class MyTreeDataProvider implements vscode.TreeDataProvider&lt;MyTreeItem&gt;{
    onDidChangeTreeData?: vscode.Event&lt;MyTreeItem | null | undefined&gt; | undefined;    getTreeItem(element: MyTreeItem): vscode.TreeItem | Thenable&lt;vscode.TreeItem&gt; {
        throw new Error(&#34;Method not implemented.&#34;);
    }
    getChildren(element?: MyTreeItem | undefined): vscode.ProviderResult&lt;MyTreeItem[]&gt; {
        throw new Error(&#34;Method not implemented.&#34;);
    }

    
}
</code></pre>

<p>onDidChangeTreeData是当树的数据改变后的回调，getChildren是获取它的子节点时的回调，也就是展开时的回调。</p>

<p>知道了这些，我们写一个迷你的文件管理器，最后要实现这个效果：</p>

<p><img src="https://s2.ax1x.com/2019/06/19/VOk0E9.gif" alt="效果"/></p>

<p>虽然有点丑哈，但是无伤大雅，分析一下怎么实现。</p>

<p>首先点击它会获取当前工作空间的路径，然后读取子文件，如果是文件夹，则能展开继续获取子文件，如果是文件，则不能。</p>

<p>工作空间路径，我们在外部传入，可以使用<code>vscode.workspace.rootPath</code>获取。</p>

<p>import:</p>

<pre><code class="language-typescript">import * as vscode from &#39;vscode&#39;;
import * as path from &#39;path&#39;;
import * as fs from &#39;fs&#39;;
</code></pre>

<p>我们先抽象实体类：</p>

<pre><code class="language-typescript">//两个辅助方法 获取图标
function lightRes(filename: string){
    return path.join(__filename, &#39;..&#39;, &#39;..&#39;, &#39;res&#39;, &#39;light&#39;, filename); 
}

function darkRes(filename: string){
    return path.join(__filename, &#39;..&#39;, &#39;..&#39;, &#39;res&#39;, &#39;dark&#39;, filename); 
}


export class MyTreeItem extends vscode.TreeItem {
    //提供一个parent，当它是null时则代表它是根节点
    constructor(public readonly label: string, public readonly collapsibleState: vscode.TreeItemCollapsibleState,public parent: MyTreeItem | null) {
        super(label, collapsibleState);
    }
    //提供一个path的get方法用于获取路径，如果是根节点则就是当前的label，否则还要加上父节点的
    get path(): string {
        return this.parent?path.join(this.parent.path,this.label):this.label;
    }

    //对文件和文件夹进行分类 如果collapsibleState是None则代表它是文件
    iconPath = {
        light: this.collapsibleState == vscode.TreeItemCollapsibleState.None ? lightRes(&#39;file.svg&#39;) :  lightRes(&#39;dir.svg&#39;),
        dark: this.collapsibleState == vscode.TreeItemCollapsibleState.None ?  darkRes(&#39;file.svg&#39;) :  darkRes(&#39;dir.svg&#39;)
    }

}
</code></pre>

<p>然后去写Provider的实现类：</p>

<pre><code class="language-typescript">export class MyTreeDataProvider implements vscode.TreeDataProvider&lt;MyTreeItem&gt;{
    //让外部传入根路径
    constructor(public rootDir: string){}
    
    //当发生改变后进行刷新UI 但是我不太明白这两行 明白的大佬麻烦告诉我下 嘿嘿～
    private _onDidChangeTreeData: vscode.EventEmitter&lt;MyTreeItem | undefined&gt; = new vscode.EventEmitter&lt;MyTreeItem | undefined&gt;();
    readonly onDidChangeTreeData: vscode.Event&lt;MyTreeItem | undefined&gt; = this._onDidChangeTreeData.event;

    
    getTreeItem(element: MyTreeItem): vscode.TreeItem {
		return element;
	}

    //关键，获取子节点
    getChildren(element?: MyTreeItem | undefined): vscode.ProviderResult&lt;MyTreeItem[]&gt; {
        //当element不存在，则代表它是根节点，这时我们把this.rootDir设进去，并且让它默认展开
        if(!element){
            return Promise.resolve([new MyTreeItem(this.rootDir,vscode.TreeItemCollapsibleState.Expanded,null)]);
        }else{
            let items: MyTreeItem[] = [];
            //否则遍历文件夹
            let subfiles = fs.readdirSync(element.path);
            subfiles.forEach(file=&gt;{
                let stat = fs.statSync(path.join(element.path,file));
                //如果是目录则设置它可以展开，否则设置它不可展开
                items.push(new MyTreeItem(file,(stat.isDirectory()?vscode.TreeItemCollapsibleState.Collapsed:vscode.TreeItemCollapsibleState.None),element))
            })
            return Promise.resolve(items);
        }
    }
}
</code></pre>

<p>然后在<code>extension.ts</code>中注册它：</p>

<pre><code class="language-typescript">context.subscriptions.push(
    vscode.window.registerTreeDataProvider(&#39;treeItems&#39;,new MyTreeDataProvider(vscode.workspace.rootPath as string))
);
</code></pre>

<p>完活。运行试试吧。</p>

<h2>添加功能</h2>

<p>现在它好像啥功能都没有呢，只能展开关闭，这是很蛋疼的一件事。我们给它添加一些功能，比如删除文件，打开文件。</p>

<p>在<code>menus</code>节点中我们可以设置关于这些项目的一些操作。</p>

<pre><code class="language-json">&#34;menus&#34;: {
    &#34;view/item/context&#34;: [
        {
            &#34;command&#34;: &#34;tree.delete&#34;,
            &#34;when&#34;: &#34;view == treeItems &amp;&amp; viewItem == fileItems&#34;
        },
        {
            &#34;command&#34;: &#34;tree.delete&#34;,
            &#34;when&#34;: &#34;view == treeItems &amp;&amp; viewItem == dirItems&#34;
        },
        {
            &#34;command&#34;: &#34;tree.open&#34;,
            &#34;group&#34;: &#34;inline&#34;,
            &#34;when&#34;: &#34;view == treeItems &amp;&amp; viewItem == fileItems&#34;
        }
    ]
}
</code></pre>

<p><code>view/item/context</code>设置每一个项目的菜单，我们提供两个菜单，分别是打开文件和删除文件。</p>

<p><code>when</code>中我们设置了当view是treeItems并且viewItem的值等于特定值时才出现，viewItem我们一会在代码里设置。</p>

<p>menus节点中关于侧栏的其他设置请走<a href="https://code.visualstudio.com/api/extension-guides/tree-view#view-actions">这边</a></p>

<p>注册命令：</p>

<pre><code class="language-json">&#34;commands&#34;:[
    {
        &#34;command&#34;: &#34;tree.delete&#34;,
        &#34;title&#34;: &#34;Delete&#34;
    },
    {
        &#34;command&#34;: &#34;tree.open&#34;,
        &#34;title&#34;: &#34;Open&#34;
    }
]
</code></pre>

<p>当然可以设置图标，我这里没设置。</p>

<p>在再Provider中添加几个方法，供实现功能：</p>

<pre><code class="language-typescript">delete(element: MyTreeItem){
    let path = element.path;
    let stat = fs.statSync(path);
    if(stat.isDirectory()){
        exec(&#39;rm -rf &#34;&#39;+path+&#39;&#34;&#39;)
    }else{
        fs.unlinkSync(path);
    }
    this.refresh();
}

open(element: MyTreeItem){
    vscode.window.showTextDocument(vscode.Uri.file(element.path))
}

//刷新
refresh(): void {
    this._onDidChangeTreeData.fire();
}
</code></pre>

<p>最后在TreeItem类里加入这样一行代码：</p>

<pre><code class="language-typescript">contextValue = this.collapsibleState == vscode.TreeItemCollapsibleState.None ? &#34;fileItems&#34; : &#34;dirItems&#34;;
</code></pre>

<p>这就是设置刚刚package.json中viewItem的取值。</p>

<p>然后就是extension.ts</p>

<pre><code class="language-typescript">const provider = new MyTreeDataProvider(vscode.workspace.rootPath as string);
vscode.window.registerTreeDataProvider(&#39;treeItems&#39;,provider)
vscode.commands.registerCommand(&#39;tree.delete&#39;,(node: MyTreeItem) =&gt; provider.delete(node))
vscode.commands.registerCommand(&#39;tree.open&#39;,(node: MyTreeItem)=&gt; provider.open(node))
</code></pre>

<p><img src="http://nsimg.cn-bj.ufileos.com/img-1560992418573.png" alt="img"/></p>

<p>运行，可以达到我们预期的效果，但是我们发现，使用一个open按钮打开文档不太符合我们的使用习惯，我们习惯点击项目打开文件，所以还要继续扩展功能。其实TreeItem有一个command属性，就是用于设置点击该项目时触发的命令，我们可以在TreeItem的实体类中或者provider的<code>getTreeItem</code>扩展它。</p>

<pre><code class="language-typescript">getTreeItem(element: MyTreeItem): vscode.TreeItem {
    element.command = element.collapsibleState == vscode.TreeItemCollapsibleState.None? {
        command: &#39;tree.open&#39;,
        arguments: [element],
        title: &#39;Open&#39;
    } : void 0;
    return element;
}
</code></pre>

<p>现在，点击项目的时候也会打开文件了。</p>

<p><strong><a href="/post/vscode-ext1#目录">点此返回目录</a></strong></p>

<hr/>

<h2>参考</h2>

<p><a href="https://code.visualstudio.com/api/extension-guides/tree-view#">tree-view</a></p>
</body></html>