<html><head><title>KNN算法</title></head><body><p>今早自己瞎实现了一个KNN算法，觉得挺简单，感觉我踏入机器学习领域就是很快的事。然后刷了下吴恩达老师的课，瞬间懵逼。。数学不行还是别来了，我先去学数学了。(不过老师讲得很好，最起码一个中专生都听懂了不少)</p>

<p>KNN是一个分类算法，就是K近邻算法，就是在若干数据中找出K个与输入数据最近的数据，然后看一下它们中哪一类是最多的，就预测输入数据属于哪一类。</p>

<p>这个算法可以说非常简单了，其实整个算法就用到了一个公式，就是欧里几德距离。</p>

<p>$
dist(X,Y)=\sqrt{\sum\limits_{i=1}^{N} (x_i-y_i)^2}
$</p>

<p>其中，X和Y是N维空间里的两个点，业务中它们就是有N个属性的两个不同的数据，然后对它们每个维度所在的位置做差，平方然后求和，最后开根号。</p>

<p>假设我需要通过各种镜头的次数判断一个电影属于什么类型，并给如下数据集：</p>

<pre><code class="language-python">tag_name = [&#39;爱情动作片&#39;,&#39;爱情片&#39;,&#39;动作片&#39;]

//每一行的第一个元素表示接吻镜头，第二个元素表示武打镜头
train_data = np.array([[25,32],
                       [65,21],
                       [135,42],
                       [32,0],
                       [15,62],
                       [11,2],
                       [66,10],
                       [55,49],
                       [1,52],
                       [2,30],
                       [65,122],
                       [12,15],
                       [30,33],
                       [65,69]])
//tag表示训练数据中对应位置的片子的类型
train_tag = np.array([0,1,1,1,2,1,1,0,2,2,2,0,0,0])
</code></pre>

<p>这时，我需要通过一个函数<code>g</code>来预测其他电影的类型。比如：</p>

<pre><code class="language-python">&gt;&gt;&gt; g([65,21])
爱情片
</code></pre>

<pre><code class="language-python">def g(attr,k=3):
    //生成距离列表
    distance_list = [0] * len(train_data)
    //计算每一个训练数据和输入数据的欧氏距离
    for index,m in enumerate(train_data):
        d = math.sqrt((attr[0]-m[0])**2+(attr[1]-m[1])**2)
        distance_list[index] = (d,train_tag[index])
    //排序并取前k个
    distance_list = sorted(distance_list)[0:k]
    //n记录前k个中出现的每个类别的个数
    n = [0]*3
    for d in distance_list:
        n[d[1]] = n[d[1]] + 1
    max_p = n.index(max(n))
    print(tag_name[max_p])
</code></pre>

<p>大概就是这样，这个是最简单的机器学习中的有监督分类算法，我自己瞎写的，如果有不对的地方欢迎指正。不说了，得学数学去了。[手动哭]</p>
</body></html>