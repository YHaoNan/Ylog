---
title: KNN算法
date: 2019-05-17 11:01:27
tags: [机器学习,python]
categories: 机器学习
---
今早自己瞎实现了一个KNN算法，觉得挺简单，感觉我踏入机器学习领域就是很快的事。然后刷了下吴恩达老师的课，瞬间懵逼。。数学不行还是别来了，我先去学数学了。(不过老师讲得很好，最起码一个中专生都听懂了不少)

KNN是一个分类算法，就是K近邻算法，就是在若干数据中找出K个与输入数据最近的数据，然后看一下它们中哪一类是最多的，就预测输入数据属于哪一类。

这个算法可以说非常简单了，其实整个算法就用到了一个公式，就是欧里几德距离。

$
dist(X,Y)=\sqrt{\sum\limits_{i=1}^{N} (x_i-y_i)^2}
$

其中，X和Y是N维空间里的两个点，业务中它们就是有N个属性的两个不同的数据，然后对它们每个维度所在的位置做差，平方然后求和，最后开根号。

假设我需要通过各种镜头的次数判断一个电影属于什么类型，并给如下数据集：
```python
tag_name = ['爱情动作片','爱情片','动作片']

//每一行的第一个元素表示接吻镜头，第二个元素表示武打镜头
train_data = np.array([[25,32],
                       [65,21],
                       [135,42],
                       [32,0],
                       [15,62],
                       [11,2],
                       [66,10],
                       [55,49],
                       [1,52],
                       [2,30],
                       [65,122],
                       [12,15],
                       [30,33],
                       [65,69]])
//tag表示训练数据中对应位置的片子的类型
train_tag = np.array([0,1,1,1,2,1,1,0,2,2,2,0,0,0])
```

这时，我需要通过一个函数`g`来预测其他电影的类型。比如：
```python
>>> g([65,21])
爱情片
```

```python
def g(attr,k=3):
    //生成距离列表
    distance_list = [0] * len(train_data)
    //计算每一个训练数据和输入数据的欧氏距离
    for index,m in enumerate(train_data):
        d = math.sqrt((attr[0]-m[0])**2+(attr[1]-m[1])**2)
        distance_list[index] = (d,train_tag[index])
    //排序并取前k个
    distance_list = sorted(distance_list)[0:k]
    //n记录前k个中出现的每个类别的个数
    n = [0]*3
    for d in distance_list:
        n[d[1]] = n[d[1]] + 1
    max_p = n.index(max(n))
    print(tag_name[max_p])
```

大概就是这样，这个是最简单的机器学习中的有监督分类算法，我自己瞎写的，如果有不对的地方欢迎指正。不说了，得学数学去了。\[手动哭\]